/**
  * This sketch demonstrates how to use an FFT to analyze
  * the audio being generated by an AudioPlayer.
  * <p>
  * FFT stands for Fast Fourier Transform, which is a 
  * method of analyzing audio that allows you to visualize 
  * the frequency content of a signal. You've seen 
  * visualizations like this before in music players 
  * and car stereos.
  * <p>
  * For more information about Minim and additional features, 
  * visit http://code.compartmental.net/minim/
  */

import ddf.minim.analysis.*;
import ddf.minim.*;
import oscP5.*;
import netP5.*;

OscP5 oscP5;
NetAddress myRemoteLocation;
NetAddress myRemoteLocation2;

Minim       minim;
AudioInput jingle;
FFT         fftLin;
FFT         fftLog;
float height3;
float height23;
float spectrumScale = 8;

boolean maxvalZeroFlag = false ;
boolean maxhighvalZeroFlag =  false;
boolean maxmediumvalZeroFlag = false;
boolean maxlowvalZeroFlag = false;


int umbralMaxVal = 10;
int umbralMaxHighHal = 10;
int umbralMaxMediumVal = 10;
int umbralMaxLowVal = 10;

void setup()
{
  size(512, 480 );
  height3 = height/3;
  height23 = 2*height/3;


  /* start oscP5, listening for incoming messages at port 12000 */
  oscP5 = new OscP5(this,12000);
    /* myRemoteLocation is a NetAddress. a NetAddress takes 2 parameters,
   * an ip address and a port number. myRemoteLocation is used as parameter in
   * oscP5.send() when sending osc packets to another computer, device, 
   * application. usage see below. for testing purposes the listening port
   * and the port of the remote location address are the same, hence you will
   * send messages back to this sketch.
   */
  myRemoteLocation = new NetAddress("127.0.0.1", 7401 );
  myRemoteLocation2 = new NetAddress("192.168.43.102", 7401 );
  frameRate(60);
  
  minim = new Minim(this);
  
  // specify that we want the audio buffers of the AudioPlayer
  // to be 1024 samples long because our FFT needs to have 
  // a power-of-two buffer size and this is a good size.
 // jingle = minim.loadFile("jingle.mp3", 1024);
  
  jingle = minim.getLineIn(Minim.STEREO, 1024);
  
  // loop the file indefinitely
  //jingle.loop();
  
  // create an FFT object that has a time-domain buffer 
  // the same size as jingle's sample buffer
  // note that this needs to be a power of two 
  // and that it means the size of the spectrum will be half as large.
  fftLin = new FFT( jingle.bufferSize(), jingle.sampleRate() );
  fftLin.linAverages( 250 );
  
  fftLog = new FFT( jingle.bufferSize(), jingle.sampleRate() );
  fftLog.logAverages( 22, 12 );
}

void beat( Float freq, Float gain, String range ) {

  Object args[] = new Object[2];
  args[0] = new Float(freq);
  args[1] = new Float(gain);
  OscMessage myMessage = new OscMessage("/beat"+range,args);
  /* send the message */
  oscP5.send(myMessage, myRemoteLocation);
   oscP5.send(myMessage, myRemoteLocation2); 
}

void beathigh( Float freq, Float gain ) {
  beat(freq,gain,"high");
}

void beatmedium( Float freq, Float gain ) {
  beat(freq,gain,"medium");
}

void beatlow( Float freq, Float gain ) {
  beat(freq,gain,"low");
}

/* incoming osc message are forwarded to the oscEvent method. */
void oscEvent(OscMessage theOscMessage) {
  /* print the address pattern and the typetag of the received OscMessage */
  print("### received an osc message.");
  print(" addrpattern: "+theOscMessage.addrPattern());
  println(" typetag: "+theOscMessage.typetag());
}

void draw()
{
  background(0);
  stroke(255);
  
  // perform a forward FFT on the samples in jingle's mix buffer,
  // which contains the mix of both the left and right channels of the file
  fftLin.forward( jingle.mix );
  fftLog.forward( jingle.mix );
  
  //print("spectrum size" + fft.specSize()  + "\n" );
  //jingle.setGain(255);
  //println(jingle.getGain());  
   int threshold = 6;
   float maxval = 0;
   float maxfreq = 0;

   float maxhighval = 0;
   float maxhighfreq = 0;
   float maxhighi = 0;

   float maxmediumval = 0;
   float maxmediumfreq = 0;
   float maxmediumi = 0;
   
   float maxlowval = 0;
   float maxlowfreq = 0;   
   float centerFrequency = 0;
   float maxlowi = 0;
   
   float minLowFrequency = 50.0;
   float maxLowFrequency = 200.0;

   float minMedFrequency = 400.0;
   float maxMedFrequency = 1500.0;

   float minHighFrequency = 1800.0;
   float maxHighFrequency = 100000.0;
    
  textSize(12);
  text(  "spec size:" + fftLin.specSize() + " buf:"+jingle.bufferSize()+" f.rate:"+jingle.sampleRate(), 10, height-10, 0 );
  text(  "avg size:" + fftLin.avgSize() + " buf:"+jingle.bufferSize()+" f.rate:"+jingle.sampleRate(), 10, height-20, 0 );


  int w = int( width/fftLin.avgSize() );
  for(int i = 0; i < fftLin.avgSize(); i++)
  {
      // draw the line for frequency band i, scaling it up a bit so we can see it
      stroke(  128*i/2,128*i/3,128*i/4 );
      fill(  128*i/2,128*i/3,128*i/4 );
      
      Float value = fftLin.getAvg(i)*spectrumScale;
      centerFrequency = fftLin.getAverageCenterFrequency(i);
      
      rect( i*w, height/2, w, -value );
      
      if (i % (w) == 0) {        
        textSize(10);
        text( ((int)centerFrequency/1000)+"kHz", i*w, height/2 + 10 + (i%2)*10 , 0);
      }  
      
      if( value > umbralMaxVal ) {  
        
        if (value>maxval) {
          maxval = value;
          maxfreq = (int)centerFrequency;
        } 
      
        if (value>maxlowval && ((centerFrequency>minLowFrequency && centerFrequency<maxLowFrequency) || ( 10<centerFrequency && centerFrequency<minLowFrequency-10)) ) {
          maxlowval = value;
          maxlowfreq = (int)centerFrequency;
          maxlowi = i*w;
        }
      
        if (value>maxmediumval && centerFrequency>=minMedFrequency && centerFrequency<maxMedFrequency ) {
          maxmediumval = value;
          maxmediumfreq = (int)centerFrequency;
          maxmediumi = i*w;
        }    
      
        if (value>maxhighval && centerFrequency>minHighFrequency && centerFrequency<maxHighFrequency ) {
          maxhighval = value;
          maxhighfreq = (int)centerFrequency;
          maxhighi = i*w;
        }  
      }  
    
  } 
  
  drawLogSpectrum();
 
   fill(  255,100,100 );
   rect( maxlowi, 100, 30*2, -maxlowval );
   
   fill(  0,255,0 );
   rect( maxmediumi, 100, 30*2, -maxmediumval );
   
   fill(  0,255,255 );
   rect( maxhighi, 100, 30*2, -maxhighval );
   
 
  if (maxval>5) {
    textSize(20);
    text( (int)maxfreq+" Hz val:"+maxval, 10, 20, 0 ); 
    beat( maxfreq, maxval, "" );
  }
  if (maxhighval>5) beathigh( maxhighfreq, maxhighval );
  else beathigh( maxhighfreq, (float)0 );
  if (maxmediumval>5) beatmedium( maxmediumfreq, maxmediumval );
  else  beatmedium( maxmediumfreq, (float)0 );
  if (maxlowval>5) beatlow( maxlowfreq, maxlowval );
  else  beatlow( maxlowfreq, (float)0 );
    
}


void drawSpectrum() {

  float centerFrequency = 0;
  
// draw the linear averages
  {
    // since linear averages group equal numbers of adjacent frequency bands
    // we can simply precalculate how many pixel wide each average's
    // rectangle should be.
    int w = int( width/fftLin.avgSize() );
    for(int i = 0; i < fftLin.avgSize(); i++)
    {
      // if the mouse is inside the bounds of this average,
      // print the center frequency and fill in the rectangle with red
      if ( mouseX >= i*w*5 && mouseX < i*w + w )
      {
        centerFrequency = fftLin.getAverageCenterFrequency(i);
       
        fill(255, 128);
        text("Linear Average Center Frequency: " + centerFrequency, 10, 10);
       
        fill(255, 0, 0);
      }
      else
      {
          fill(255);
      }
      // draw a rectangle for each average, multiply the value by spectrumScale so we can see it better
      rect(i*w*5, height23, i*w + w, height23 - fftLin.getAvg(i)*spectrumScale);
    }
  }
 
  // draw the logarithmic averages
  {
    // since logarithmically spaced averages are not equally spaced
    // we can't precompute the width for all averages
    for(int i = 0; i < fftLog.avgSize(); i++)
    {
      centerFrequency    = fftLog.getAverageCenterFrequency(i);
      // how wide is this average in Hz?
      float averageWidth = fftLog.getAverageBandWidth(i);  
     
      // we calculate the lowest and highest frequencies
      // contained in this average using the center frequency
      // and bandwidth of this average.
      float lowFreq  = centerFrequency - averageWidth/2;
      float highFreq = centerFrequency + averageWidth/2;
     
      // freqToIndex converts a frequency in Hz to a spectrum band index
      // that can be passed to getBand. in this case, we simply use the
      // index as coordinates for the rectangle we draw to represent
      // the average.
      int xl = (int)fftLog.freqToIndex(lowFreq);
      int xr = (int)fftLog.freqToIndex(highFreq);
     
      // if the mouse is inside of this average's rectangle
      // print the center frequency and set the fill color to red
      if ( mouseX >= xl && mouseX < xr )
      {
        fill(255, 128);
        text("Logarithmic Average Center Frequency: " + centerFrequency, 5, height - 25);
        fill(255, 0, 0);
      }
      else
      {
          fill(255);
      }
      // draw a rectangle for each average, multiply the value by spectrumScale so we can see it better
      rect( xl*5, height, xr, height - fftLog.getAvg(i)*spectrumScale );
    }
  }


}


void drawLogSpectrum() {
  float centerFrequency = 0;
  float maxval = 0;
  float maxfreq = 0;
  
// draw the logarithmic averages
  {
    // since logarithmically spaced averages are not equally spaced
    // we can't precompute the width for all averages
    for(int i = 0; i < fftLog.avgSize(); i++)
    {
      centerFrequency    = fftLog.getAverageCenterFrequency(i);
      
      
      // how wide is this average in Hz?
      float averageWidth = fftLog.getAverageBandWidth(i);  
     
      // we calculate the lowest and highest frequencies
      // contained in this average using the center frequency
      // and bandwidth of this average.
      float lowFreq  = centerFrequency - averageWidth/2;
      float highFreq = centerFrequency + averageWidth/2;
     
      // freqToIndex converts a frequency in Hz to a spectrum band index
      // that can be passed to getBand. in this case, we simply use the
      // index as coordinates for the rectangle we draw to represent
      // the average.
      int xl = (int)fftLog.freqToIndex(lowFreq);
      int xr = (int)fftLog.freqToIndex(highFreq);
     
      // if the mouse is inside of this average's rectangle
      // print the center frequency and set the fill color to red
      if ( mouseX >= xl && mouseX < xr )
      {
        fill(255, 255);
        text("Logarithmic Average Center Frequency: " + ((int)centerFrequency), height/2+20, height - 25);
        fill(255, 0, 0);
      }
      else
      {
          fill(255);
      }
      // draw a rectangle for each average, multiply the value by spectrumScale so we can see it better
      float value = fftLog.getAvg(i);
      if (value>maxval) {
        maxval = value;
        maxfreq = centerFrequency;
      }
      rect( xl, height-35, xr, -fftLog.getAvg(i)/2 );
    }
  }
  if (maxval>5) {
     textSize( 20 );
     text( (int)maxfreq+" Hz val:"+maxval, 10, height/2+40, 0 ); 
  }
}


